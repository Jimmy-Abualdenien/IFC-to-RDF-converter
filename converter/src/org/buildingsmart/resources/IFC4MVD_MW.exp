(*
Copyright by:
buildingSMART International Limited, 1996-2015

Any technical documentation made available by buildingSMART International Limited
is the copyrighted work of buildingSMART International Limited and is owned by the 
buildingSMART International Limited. It may be photocopied, used in software development, 
or translated into another computer language without prior written consent from 
buildingSMART International Limited provided that full attribution is given. 
Prior written consent is required if changes are made to the technical specification.

This material is delivered to you as is and buildingSMART International Limited makes 
no warranty of any kind with regard to it, including, but not limited to, the implied 
warranties as to its accuracy or fitness for a particular purpose. Any use of the 
technical documentation or the information contained therein is at the risk of the user. 
Documentation may include technical or other inaccuracies or typographical errors. 
buildingSMART International Limited shall not be liable for errors contained therein or 
for incidental consequential damages in connection with the furnishing, performance or use 
of the material. The information contained in this document is subject to change without notice.

Issue date:
Mittwoch, 20. Mai 2015

*)

SCHEMA IFC4MVD_MW;

TYPE IfcStrippedOptional = BOOLEAN;
END_TYPE;

TYPE IfcAreaMeasure = REAL;
END_TYPE;

TYPE IfcBoolean = BOOLEAN;
END_TYPE;

TYPE IfcCompoundPlaneAngleMeasure = LIST [3:4] OF INTEGER;
END_TYPE;

TYPE IfcDate = STRING;
END_TYPE;

TYPE IfcDimensionCount = INTEGER;
END_TYPE;

TYPE IfcGloballyUniqueId = STRING(22) FIXED;
END_TYPE;

TYPE IfcIdentifier = STRING(255);
END_TYPE;

TYPE IfcInteger = INTEGER;
END_TYPE;

TYPE IfcLabel = STRING(255);
END_TYPE;

TYPE IfcLengthMeasure = REAL;
END_TYPE;

TYPE IfcLogical = LOGICAL;
END_TYPE;

TYPE IfcPlanarForceMeasure = REAL;
END_TYPE;

TYPE IfcText = STRING;
END_TYPE;

TYPE IfcDoorStyleConstructionEnum = ENUMERATION OF
	(ALUMINIUM
	,HIGH_GRADE_STEEL
	,STEEL
	,WOOD
	,ALUMINIUM_WOOD
	,ALUMINIUM_PLASTIC
	,PLASTIC
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcDoorStyleOperationEnum = ENUMERATION OF
	(SINGLE_SWING_LEFT
	,SINGLE_SWING_RIGHT
	,DOUBLE_DOOR_SINGLE_SWING
	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT
	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT
	,DOUBLE_SWING_LEFT
	,DOUBLE_SWING_RIGHT
	,DOUBLE_DOOR_DOUBLE_SWING
	,SLIDING_TO_LEFT
	,SLIDING_TO_RIGHT
	,DOUBLE_DOOR_SLIDING
	,FOLDING_TO_LEFT
	,FOLDING_TO_RIGHT
	,DOUBLE_DOOR_FOLDING
	,REVOLVING
	,ROLLINGUP
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcDoorTypeEnum = ENUMERATION OF
	(DOOR
	,GATE
	,TRAPDOOR
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcDoorTypeOperationEnum = ENUMERATION OF
	(SINGLE_SWING_LEFT
	,SINGLE_SWING_RIGHT
	,DOUBLE_DOOR_SINGLE_SWING
	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT
	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT
	,DOUBLE_SWING_LEFT
	,DOUBLE_SWING_RIGHT
	,DOUBLE_DOOR_DOUBLE_SWING
	,SLIDING_TO_LEFT
	,SLIDING_TO_RIGHT
	,DOUBLE_DOOR_SLIDING
	,FOLDING_TO_LEFT
	,FOLDING_TO_RIGHT
	,DOUBLE_DOOR_FOLDING
	,REVOLVING
	,ROLLINGUP
	,SWING_FIXED_LEFT
	,SWING_FIXED_RIGHT
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcInternalOrExternalEnum = ENUMERATION OF
	(INTERNAL
	,EXTERNAL
	,EXTERNAL_EARTH
	,EXTERNAL_WATER
	,EXTERNAL_FIRE
	,NOTDEFINED);
END_TYPE;

TYPE IfcPhysicalOrVirtualEnum = ENUMERATION OF
	(PHYSICAL
	,VIRTUAL
	,NOTDEFINED);
END_TYPE;

TYPE IfcRampTypeEnum = ENUMERATION OF
	(STRAIGHT_RUN_RAMP
	,TWO_STRAIGHT_RUN_RAMP
	,QUARTER_TURN_RAMP
	,TWO_QUARTER_TURN_RAMP
	,HALF_TURN_RAMP
	,SPIRAL_RAMP
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcSIPrefix = ENUMERATION OF
	(EXA
	,PETA
	,TERA
	,GIGA
	,MEGA
	,KILO
	,HECTO
	,DECA
	,DECI
	,CENTI
	,MILLI
	,MICRO
	,NANO
	,PICO
	,FEMTO
	,ATTO);
END_TYPE;

TYPE IfcSIUnitName = ENUMERATION OF
	(AMPERE
	,BECQUEREL
	,CANDELA
	,COULOMB
	,CUBIC_METRE
	,DEGREE_CELSIUS
	,FARAD
	,GRAM
	,GRAY
	,HENRY
	,HERTZ
	,JOULE
	,KELVIN
	,LUMEN
	,LUX
	,METRE
	,MOLE
	,NEWTON
	,OHM
	,PASCAL
	,RADIAN
	,SECOND
	,SIEMENS
	,SIEVERT
	,SQUARE_METRE
	,STERADIAN
	,TESLA
	,VOLT
	,WATT
	,WEBER);
END_TYPE;

TYPE IfcSpaceTypeEnum = ENUMERATION OF
	(SPACE
	,PARKING
	,GFA
	,INTERNAL
	,EXTERNAL
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcStairTypeEnum = ENUMERATION OF
	(STRAIGHT_RUN_STAIR
	,TWO_STRAIGHT_RUN_STAIR
	,QUARTER_WINDING_STAIR
	,QUARTER_TURN_STAIR
	,HALF_WINDING_STAIR
	,HALF_TURN_STAIR
	,TWO_QUARTER_WINDING_STAIR
	,TWO_QUARTER_TURN_STAIR
	,THREE_QUARTER_WINDING_STAIR
	,THREE_QUARTER_TURN_STAIR
	,SPIRAL_STAIR
	,DOUBLE_RETURN_STAIR
	,CURVED_RUN_STAIR
	,TWO_CURVED_RUN_STAIR
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcTransportElementTypeEnum = ENUMERATION OF
	(ELEVATOR
	,ESCALATOR
	,MOVINGWALKWAY
	,CRANEWAY
	,LIFTINGGEAR
	,USERDEFINED
	,NOTDEFINED);
END_TYPE;

TYPE IfcUnitEnum = ENUMERATION OF
	(ABSORBEDDOSEUNIT
	,AMOUNTOFSUBSTANCEUNIT
	,AREAUNIT
	,DOSEEQUIVALENTUNIT
	,ELECTRICCAPACITANCEUNIT
	,ELECTRICCHARGEUNIT
	,ELECTRICCONDUCTANCEUNIT
	,ELECTRICCURRENTUNIT
	,ELECTRICRESISTANCEUNIT
	,ELECTRICVOLTAGEUNIT
	,ENERGYUNIT
	,FORCEUNIT
	,FREQUENCYUNIT
	,ILLUMINANCEUNIT
	,INDUCTANCEUNIT
	,LENGTHUNIT
	,LUMINOUSFLUXUNIT
	,LUMINOUSINTENSITYUNIT
	,MAGNETICFLUXDENSITYUNIT
	,MAGNETICFLUXUNIT
	,MASSUNIT
	,PLANEANGLEUNIT
	,POWERUNIT
	,PRESSUREUNIT
	,RADIOACTIVITYUNIT
	,SOLIDANGLEUNIT
	,THERMODYNAMICTEMPERATUREUNIT
	,TIMEUNIT
	,VOLUMEUNIT
	,USERDEFINED);
END_TYPE;

TYPE IfcAxis2Placement = SELECT
	(IfcAxis2Placement3D);
END_TYPE;

TYPE IfcClassificationSelect = SELECT
	(IfcClassification
	,IfcClassificationReference);
END_TYPE;

TYPE IfcDefinitionSelect = SELECT
	(IfcObjectDefinition
	,IfcPropertyDefinition);
END_TYPE;

TYPE IfcPropertySetDefinitionSelect = SELECT
	(IfcPropertySetDefinition);
END_TYPE;

TYPE IfcSpaceBoundarySelect = SELECT
	(IfcSpace);
END_TYPE;

TYPE IfcSurfaceOrFaceSurface = SELECT
);
END_TYPE;

TYPE IfcUnit = SELECT
	(IfcNamedUnit);
END_TYPE;

ENTITY IfcAddress
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcPostalAddress));
	Purpose : OPTIONAL IfcStrippedOptional;
	Description : OPTIONAL IfcStrippedOptional;
	UserDefinedPurpose : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcAxis2Placement3D
 SUBTYPE OF (IfcPlacement);
	Axis : OPTIONAL IfcDirection;
	RefDirection : OPTIONAL IfcDirection;
 DERIVE
	P : LIST [3:3] OF IfcDirection := IfcBuildAxes(Axis, RefDirection);
END_ENTITY;

ENTITY IfcBuilding
 SUBTYPE OF (IfcSpatialStructureElement);
	ElevationOfRefHeight : OPTIONAL IfcLengthMeasure;
	ElevationOfTerrain : OPTIONAL IfcLengthMeasure;
	BuildingAddress : OPTIONAL IfcPostalAddress;
END_ENTITY;

ENTITY IfcBuildingElement
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcDoor
    ,IfcRamp
    ,IfcStair))
 SUBTYPE OF (IfcElement);
END_ENTITY;

ENTITY IfcBuildingElementType
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcDoorType
    ,IfcRampType
    ,IfcStairType))
 SUBTYPE OF (IfcElementType);
END_ENTITY;

ENTITY IfcBuildingStorey
 SUBTYPE OF (IfcSpatialStructureElement);
	Elevation : OPTIONAL IfcLengthMeasure;
END_ENTITY;

ENTITY IfcCartesianPoint
 SUBTYPE OF (IfcPoint);
	Coordinates : LIST [1:3] OF IfcLengthMeasure;
 DERIVE
	Dim : IfcDimensionCount := HIINDEX(Coordinates);
END_ENTITY;

ENTITY IfcCartesianTransformationOperator
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcCartesianTransformationOperator3D))
 SUBTYPE OF (IfcGeometricRepresentationItem);
	Axis1 : OPTIONAL IfcStrippedOptional;
	Axis2 : OPTIONAL IfcStrippedOptional;
	LocalOrigin : IfcCartesianPoint;
	Scale : OPTIONAL IfcStrippedOptional;
 DERIVE
	Scl : REAL := NVL(Scale, 1.0);
	Dim : IfcDimensionCount := LocalOrigin.Dim;
END_ENTITY;

ENTITY IfcCartesianTransformationOperator3D
 SUBTYPE OF (IfcCartesianTransformationOperator);
	Axis3 : OPTIONAL IfcStrippedOptional;
 DERIVE
	U : LIST [3:3] OF IfcDirection := IfcBaseAxis(3,SELF\IfcCartesianTransformationOperator.Axis1,
SELF\IfcCartesianTransformationOperator.Axis2,Axis3);
END_ENTITY;

ENTITY IfcClassification
 SUBTYPE OF (IfcExternalInformation);
	Source : OPTIONAL IfcLabel;
	Edition : OPTIONAL IfcLabel;
	EditionDate : OPTIONAL IfcDate;
	Name : IfcLabel;
	Description : OPTIONAL IfcStrippedOptional;
	Location : OPTIONAL IfcStrippedOptional;
	ReferenceTokens : OPTIONAL LIST [1:?] OF IfcIdentifier;
 INVERSE
	ClassificationForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;
	HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;
END_ENTITY;

ENTITY IfcClassificationReference
 SUBTYPE OF (IfcExternalReference);
	ReferencedSource : OPTIONAL IfcClassificationReferenceSelect;
	Description : OPTIONAL IfcStrippedOptional;
	Sort : OPTIONAL IfcStrippedOptional;
 INVERSE
	ClassificationRefForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;
	HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;
END_ENTITY;

ENTITY IfcClosedShell
 SUBTYPE OF (IfcConnectedFaceSet);
END_ENTITY;

ENTITY IfcConnectedFaceSet
 SUPERTYPE OF (ONEOF
    (IfcClosedShell))
 SUBTYPE OF (IfcTopologicalRepresentationItem);
	CfsFaces : SET [1:?] OF IfcFace;
END_ENTITY;

ENTITY IfcConnectionGeometry
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcConnectionSurfaceGeometry));
END_ENTITY;

ENTITY IfcConnectionSurfaceGeometry
 SUBTYPE OF (IfcConnectionGeometry);
	SurfaceOnRelatingElement : IfcSurfaceOrFaceSurface;
	SurfaceOnRelatedElement : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcContext
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcProject))
 SUBTYPE OF (IfcObjectDefinition);
	ObjectType : OPTIONAL IfcStrippedOptional;
	LongName : OPTIONAL IfcStrippedOptional;
	Phase : OPTIONAL IfcStrippedOptional;
	RepresentationContexts : OPTIONAL SET [1:?] OF IfcRepresentationContext;
	UnitsInContext : OPTIONAL IfcUnitAssignment;
 INVERSE
	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;
END_ENTITY;

ENTITY IfcDimensionalExponents;
	LengthExponent : INTEGER;
	MassExponent : INTEGER;
	TimeExponent : INTEGER;
	ElectricCurrentExponent : INTEGER;
	ThermodynamicTemperatureExponent : INTEGER;
	AmountOfSubstanceExponent : INTEGER;
	LuminousIntensityExponent : INTEGER;
END_ENTITY;

ENTITY IfcDirection
 SUBTYPE OF (IfcGeometricRepresentationItem);
	DirectionRatios : LIST [2:3] OF REAL;
 DERIVE
	Dim : IfcDimensionCount := HIINDEX(DirectionRatios);
END_ENTITY;

ENTITY IfcDoor
 SUPERTYPE OF (ONEOF
    (IfcDoorStandardCase))
 SUBTYPE OF (IfcBuildingElement);
	OverallHeight : OPTIONAL IfcStrippedOptional;
	OverallWidth : OPTIONAL IfcStrippedOptional;
	PredefinedType : OPTIONAL IfcDoorTypeEnum;
	OperationType : OPTIONAL IfcStrippedOptional;
	UserDefinedOperationType : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcDoorStandardCase
 SUBTYPE OF (IfcDoor);
END_ENTITY;

ENTITY IfcDoorStyle
 SUBTYPE OF (IfcTypeProduct);
	OperationType : IfcDoorStyleOperationEnum;
	ConstructionType : IfcDoorStyleConstructionEnum;
	ParameterTakesPrecedence : BOOLEAN;
	Sizeable : BOOLEAN;
END_ENTITY;

ENTITY IfcDoorType
 SUBTYPE OF (IfcBuildingElementType);
	PredefinedType : IfcDoorTypeEnum;
	OperationType : IfcDoorTypeOperationEnum;
	ParameterTakesPrecedence : OPTIONAL IfcStrippedOptional;
	UserDefinedOperationType : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcElement
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcBuildingElement
    ,IfcTransportElement))
 SUBTYPE OF (IfcProduct);
	Tag : OPTIONAL IfcStrippedOptional;
 INVERSE
	ProvidesBoundaries : SET [0:?] OF IfcRelSpaceBoundary FOR RelatedBuildingElement;
	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;
END_ENTITY;

ENTITY IfcElementType
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcBuildingElementType
    ,IfcTransportElementType))
 SUBTYPE OF (IfcTypeProduct);
	ElementType : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcExternalInformation
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcClassification));
END_ENTITY;

ENTITY IfcExternalReference
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcClassificationReference));
	Location : OPTIONAL IfcStrippedOptional;
	Identification : OPTIONAL IfcIdentifier;
	Name : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcFace
 SUBTYPE OF (IfcTopologicalRepresentationItem);
	Bounds : SET [1:?] OF IfcFaceBound;
END_ENTITY;

ENTITY IfcFaceBound
 SUBTYPE OF (IfcTopologicalRepresentationItem);
	Bound : IfcLoop;
	Orientation : BOOLEAN;
END_ENTITY;

ENTITY IfcFacetedBrep
 SUBTYPE OF (IfcManifoldSolidBrep);
END_ENTITY;

ENTITY IfcGeometricRepresentationContext
 SUBTYPE OF (IfcRepresentationContext);
	CoordinateSpaceDimension : IfcDimensionCount;
	Precision : OPTIONAL IfcStrippedOptional;
	WorldCoordinateSystem : IfcAxis2Placement;
	TrueNorth : OPTIONAL IfcDirection;
END_ENTITY;

ENTITY IfcGeometricRepresentationItem
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcCartesianTransformationOperator
    ,IfcDirection
    ,IfcPlacement
    ,IfcPoint
    ,IfcSolidModel))
 SUBTYPE OF (IfcRepresentationItem);
END_ENTITY;

ENTITY IfcLocalPlacement
 SUBTYPE OF (IfcObjectPlacement);
	PlacementRelTo : OPTIONAL IfcObjectPlacement;
	RelativePlacement : IfcAxis2Placement;
END_ENTITY;

ENTITY IfcLoop
 SUBTYPE OF (IfcTopologicalRepresentationItem);
END_ENTITY;

ENTITY IfcManifoldSolidBrep
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcFacetedBrep))
 SUBTYPE OF (IfcSolidModel);
	Outer : IfcClosedShell;
END_ENTITY;

ENTITY IfcMappedItem
 SUBTYPE OF (IfcRepresentationItem);
	MappingSource : IfcRepresentationMap;
	MappingTarget : IfcCartesianTransformationOperator;
END_ENTITY;

ENTITY IfcNamedUnit
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcSIUnit));
	Dimensions : IfcDimensionalExponents;
	UnitType : IfcUnitEnum;
END_ENTITY;

ENTITY IfcObject
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcProduct))
 SUBTYPE OF (IfcObjectDefinition);
	ObjectType : OPTIONAL IfcStrippedOptional;
 INVERSE
	IsTypedBy : SET [0:1] OF IfcRelDefinesByType FOR RelatedObjects;
	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;
END_ENTITY;

ENTITY IfcObjectDefinition
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcContext
    ,IfcObject
    ,IfcTypeObject))
 SUBTYPE OF (IfcRoot);
 INVERSE
	IsDecomposedBy : SET [0:?] OF IfcRelAggregates FOR RelatingObject;
	Decomposes : SET [0:1] OF IfcRelAggregates FOR RelatedObjects;
	HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;
END_ENTITY;

ENTITY IfcObjectPlacement
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcLocalPlacement));
 INVERSE
	PlacesObject : SET [0:?] OF IfcProduct FOR ObjectPlacement;
	ReferencedByPlacements : SET [0:?] OF IfcLocalPlacement FOR PlacementRelTo;
END_ENTITY;

ENTITY IfcPlacement
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcAxis2Placement3D))
 SUBTYPE OF (IfcGeometricRepresentationItem);
	Location : IfcCartesianPoint;
 DERIVE
	Dim : IfcDimensionCount := Location.Dim;
END_ENTITY;

ENTITY IfcPoint
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcCartesianPoint))
 SUBTYPE OF (IfcGeometricRepresentationItem);
END_ENTITY;

ENTITY IfcPostalAddress
 SUBTYPE OF (IfcAddress);
	InternalLocation : OPTIONAL IfcStrippedOptional;
	AddressLines : OPTIONAL LIST [1:?] OF IfcLabel;
	PostalBox : OPTIONAL IfcStrippedOptional;
	Town : OPTIONAL IfcLabel;
	Region : OPTIONAL IfcLabel;
	PostalCode : OPTIONAL IfcLabel;
	Country : OPTIONAL IfcLabel;
END_ENTITY;

ENTITY IfcProduct
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcElement
    ,IfcSpatialElement))
 SUBTYPE OF (IfcObject);
	ObjectPlacement : OPTIONAL IfcObjectPlacement;
	Representation : OPTIONAL IfcProductRepresentation;
END_ENTITY;

ENTITY IfcProductDefinitionShape
 SUBTYPE OF (IfcProductRepresentation);
 INVERSE
	ShapeOfProduct : SET [1:?] OF IfcProduct FOR Representation;
END_ENTITY;

ENTITY IfcProductRepresentation
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcProductDefinitionShape));
	Name : OPTIONAL IfcStrippedOptional;
	Description : OPTIONAL IfcStrippedOptional;
	Representations : LIST [1:?] OF IfcRepresentation;
END_ENTITY;

ENTITY IfcProject
 SUBTYPE OF (IfcContext);
END_ENTITY;

ENTITY IfcProperty
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcSimpleProperty))
 SUBTYPE OF (IfcPropertyAbstraction);
	Name : IfcIdentifier;
	Description : OPTIONAL IfcStrippedOptional;
 INVERSE
	PartOfPset : SET [0:?] OF IfcPropertySet FOR HasProperties;
END_ENTITY;

ENTITY IfcPropertyAbstraction
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcProperty));
END_ENTITY;

ENTITY IfcPropertyDefinition
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcPropertySetDefinition))
 SUBTYPE OF (IfcRoot);
 INVERSE
	HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;
END_ENTITY;

ENTITY IfcPropertySet
 SUBTYPE OF (IfcPropertySetDefinition);
	HasProperties : SET [1:?] OF IfcProperty;
END_ENTITY;

ENTITY IfcPropertySetDefinition
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcPropertySet))
 SUBTYPE OF (IfcPropertyDefinition);
 INVERSE
	DefinesType : SET [0:?] OF IfcTypeObject FOR HasPropertySets;
	DefinesOccurrence : SET [0:1] OF IfcRelDefinesByProperties FOR RelatingPropertyDefinition;
END_ENTITY;

ENTITY IfcPropertySingleValue
 SUBTYPE OF (IfcSimpleProperty);
	NominalValue : OPTIONAL IfcValue;
	Unit : OPTIONAL IfcUnit;
END_ENTITY;

ENTITY IfcRamp
 SUBTYPE OF (IfcBuildingElement);
	PredefinedType : OPTIONAL IfcRampTypeEnum;
END_ENTITY;

ENTITY IfcRampType
 SUBTYPE OF (IfcBuildingElementType);
	PredefinedType : IfcRampTypeEnum;
END_ENTITY;

ENTITY IfcRelAggregates
 SUBTYPE OF (IfcRelDecomposes);
	RelatingObject : IfcObjectDefinition;
	RelatedObjects : SET [1:?] OF IfcObjectDefinition;
END_ENTITY;

ENTITY IfcRelAssociates
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcRelAssociatesClassification))
 SUBTYPE OF (IfcRelationship);
	RelatedObjects : SET [1:?] OF IfcDefinitionSelect;
END_ENTITY;

ENTITY IfcRelAssociatesClassification
 SUBTYPE OF (IfcRelAssociates);
	RelatingClassification : IfcClassificationSelect;
END_ENTITY;

ENTITY IfcRelConnects
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcRelContainedInSpatialStructure
    ,IfcRelSpaceBoundary))
 SUBTYPE OF (IfcRelationship);
END_ENTITY;

ENTITY IfcRelContainedInSpatialStructure
 SUBTYPE OF (IfcRelConnects);
	RelatedElements : SET [1:?] OF IfcProduct;
	RelatingStructure : IfcSpatialElement;
END_ENTITY;

ENTITY IfcRelDecomposes
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcRelAggregates))
 SUBTYPE OF (IfcRelationship);
END_ENTITY;

ENTITY IfcRelDefines
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcRelDefinesByProperties
    ,IfcRelDefinesByType))
 SUBTYPE OF (IfcRelationship);
END_ENTITY;

ENTITY IfcRelDefinesByProperties
 SUBTYPE OF (IfcRelDefines);
	RelatedObjects : SET [1:1] OF IfcObjectDefinition;
	RelatingPropertyDefinition : IfcPropertySetDefinitionSelect;
END_ENTITY;

ENTITY IfcRelDefinesByType
 SUBTYPE OF (IfcRelDefines);
	RelatedObjects : SET [1:?] OF IfcObject;
	RelatingType : IfcTypeObject;
END_ENTITY;

ENTITY IfcRelSpaceBoundary
 SUBTYPE OF (IfcRelConnects);
	RelatingSpace : IfcSpaceBoundarySelect;
	RelatedBuildingElement : IfcElement;
	ConnectionGeometry : OPTIONAL IfcConnectionGeometry;
	PhysicalOrVirtualBoundary : IfcPhysicalOrVirtualEnum;
	InternalOrExternalBoundary : IfcInternalOrExternalEnum;
END_ENTITY;

ENTITY IfcRelationship
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcRelAssociates
    ,IfcRelConnects
    ,IfcRelDecomposes
    ,IfcRelDefines))
 SUBTYPE OF (IfcRoot);
END_ENTITY;

ENTITY IfcRepresentation
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcShapeModel));
	ContextOfItems : IfcRepresentationContext;
	RepresentationIdentifier : OPTIONAL IfcLabel;
	RepresentationType : OPTIONAL IfcLabel;
	Items : SET [1:?] OF IfcRepresentationItem;
 INVERSE
	RepresentationMap : SET [0:1] OF IfcRepresentationMap FOR MappedRepresentation;
	OfProductRepresentation : SET [0:?] OF IfcProductRepresentation FOR Representations;
END_ENTITY;

ENTITY IfcRepresentationContext
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcGeometricRepresentationContext));
	ContextIdentifier : OPTIONAL IfcLabel;
	ContextType : OPTIONAL IfcLabel;
 INVERSE
	RepresentationsInContext : SET [0:?] OF IfcRepresentation FOR ContextOfItems;
END_ENTITY;

ENTITY IfcRepresentationItem
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcGeometricRepresentationItem
    ,IfcMappedItem
    ,IfcTopologicalRepresentationItem));
END_ENTITY;

ENTITY IfcRepresentationMap;
	MappingOrigin : IfcAxis2Placement;
	MappedRepresentation : IfcRepresentation;
 INVERSE
	MapUsage : SET [0:?] OF IfcMappedItem FOR MappingSource;
END_ENTITY;

ENTITY IfcRoot
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcObjectDefinition
    ,IfcPropertyDefinition
    ,IfcRelationship));
	GlobalId : IfcGloballyUniqueId;
	OwnerHistory : OPTIONAL IfcStrippedOptional;
	Name : OPTIONAL IfcLabel;
	Description : OPTIONAL IfcText;
END_ENTITY;

ENTITY IfcSIUnit
 SUBTYPE OF (IfcNamedUnit);
	Prefix : OPTIONAL IfcSIPrefix;
	Name : IfcSIUnitName;
 DERIVE
	SELF\IfcNamedUnit.Dimensions : IfcDimensionalExponents := IfcDimensionsForSiUnit (SELF.Name);
END_ENTITY;

ENTITY IfcShapeModel
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcShapeRepresentation))
 SUBTYPE OF (IfcRepresentation);
END_ENTITY;

ENTITY IfcShapeRepresentation
 SUBTYPE OF (IfcShapeModel);
END_ENTITY;

ENTITY IfcSimpleProperty
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcPropertySingleValue))
 SUBTYPE OF (IfcProperty);
END_ENTITY;

ENTITY IfcSite
 SUBTYPE OF (IfcSpatialStructureElement);
	RefLatitude : OPTIONAL IfcCompoundPlaneAngleMeasure;
	RefLongitude : OPTIONAL IfcCompoundPlaneAngleMeasure;
	RefElevation : OPTIONAL IfcLengthMeasure;
	LandTitleNumber : OPTIONAL IfcLabel;
	SiteAddress : OPTIONAL IfcPostalAddress;
END_ENTITY;

ENTITY IfcSolidModel
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcManifoldSolidBrep))
 SUBTYPE OF (IfcGeometricRepresentationItem);
 DERIVE
	Dim : IfcDimensionCount := 3;
END_ENTITY;

ENTITY IfcSpace
 SUBTYPE OF (IfcSpatialStructureElement);
	PredefinedType : OPTIONAL IfcSpaceTypeEnum;
	ElevationWithFlooring : OPTIONAL IfcStrippedOptional;
 INVERSE
	BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;
END_ENTITY;

ENTITY IfcSpatialElement
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcSpatialStructureElement))
 SUBTYPE OF (IfcProduct);
	LongName : OPTIONAL IfcStrippedOptional;
 INVERSE
	ContainsElements : SET [0:?] OF IfcRelContainedInSpatialStructure FOR RelatingStructure;
END_ENTITY;

ENTITY IfcSpatialStructureElement
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcBuilding
    ,IfcBuildingStorey
    ,IfcSite
    ,IfcSpace))
 SUBTYPE OF (IfcSpatialElement);
	CompositionType : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcStair
 SUBTYPE OF (IfcBuildingElement);
	PredefinedType : OPTIONAL IfcStairTypeEnum;
END_ENTITY;

ENTITY IfcStairType
 SUBTYPE OF (IfcBuildingElementType);
	PredefinedType : IfcStairTypeEnum;
END_ENTITY;

ENTITY IfcTopologicalRepresentationItem
 ABSTRACT SUPERTYPE OF (ONEOF
    (IfcConnectedFaceSet
    ,IfcFace
    ,IfcFaceBound
    ,IfcLoop))
 SUBTYPE OF (IfcRepresentationItem);
END_ENTITY;

ENTITY IfcTransportElement
 SUBTYPE OF (IfcElement);
	PredefinedType : OPTIONAL IfcTransportElementTypeEnum;
END_ENTITY;

ENTITY IfcTransportElementType
 SUBTYPE OF (IfcElementType);
	PredefinedType : IfcTransportElementTypeEnum;
END_ENTITY;

ENTITY IfcTypeObject
 SUPERTYPE OF (ONEOF
    (IfcTypeProduct))
 SUBTYPE OF (IfcObjectDefinition);
	ApplicableOccurrence : OPTIONAL IfcStrippedOptional;
	HasPropertySets : OPTIONAL SET [1:?] OF IfcStrippedOptional;
 INVERSE
	Types : SET [0:1] OF IfcRelDefinesByType FOR RelatingType;
END_ENTITY;

ENTITY IfcTypeProduct
 SUPERTYPE OF (ONEOF
    (IfcDoorStyle
    ,IfcElementType))
 SUBTYPE OF (IfcTypeObject);
	RepresentationMaps : OPTIONAL LIST [1:?] OF UNIQUE IfcRepresentationMap;
	Tag : OPTIONAL IfcStrippedOptional;
END_ENTITY;

ENTITY IfcUnitAssignment;
	Units : SET [1:?] OF IfcUnit;
END_ENTITY;

FUNCTION IfcBaseAxis
(Dim : INTEGER; 
   Axis1, Axis2, Axis3 : IfcDirection) 
    : LIST [2:3] OF IfcDirection;

LOCAL
  U : LIST [2:3] OF IfcDirection;
  Factor : REAL;
  D1, D2 : IfcDirection;
END_LOCAL;

  IF (Dim = 3) THEN 
    D1 := NVL(IfcNormalise(Axis3), IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,0.0,1.0]));
    D2 := IfcFirstProjAxis(D1, Axis1);
    U  := [D2, IfcSecondProjAxis(D1, D2, Axis2), D1];
  ELSE
    IF EXISTS(Axis1) THEN
      D1 := IfcNormalise(Axis1);
      U  := [D1, IfcOrthogonalComplement(D1)];
      IF EXISTS(Axis2) THEN
        Factor := IfcDotProduct(Axis2, U[2]);
        IF (Factor < 0.0) THEN
          U[2].DirectionRatios[1] := -U[2].DirectionRatios[1];
          U[2].DirectionRatios[2] := -U[2].DirectionRatios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(Axis2) THEN
        D1 := IfcNormalise(Axis2);
        U  := [IfcOrthogonalComplement(D1), D1];
        U[1].DirectionRatios[1] := -U[1].DirectionRatios[1];
        U[1].DirectionRatios[2] := -U[1].DirectionRatios[2];
        ELSE
          U := [IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([1.0, 0.0]), 
                IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(U);
END_FUNCTION;

FUNCTION IfcBooleanChoose
(B : BOOLEAN ;
     Choice1, Choice2 : Generic : Item) : Generic : Item;
  IF B THEN
     RETURN (Choice1);
  ELSE
     RETURN (Choice2);
  END_IF;
END_FUNCTION;

FUNCTION IfcBuild2Axes
(RefDirection : IfcDirection)
    : LIST [2:2] OF IfcDirection;
LOCAL
  D : IfcDirection := NVL(IfcNormalise(RefDirection),
      IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([1.0,0.0]));
END_LOCAL;
  RETURN([D, IfcOrthogonalComplement(D)]);
END_FUNCTION;

FUNCTION IfcBuildAxes
(Axis, RefDirection : IfcDirection) 
    : LIST [3:3] OF IfcDirection;
LOCAL
  D1, D2 : IfcDirection;
END_LOCAL;
  D1 := NVL(IfcNormalise(Axis), IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,0.0,1.0]));
  D2 := IfcFirstProjAxis(D1, RefDirection);
  RETURN ([D2, IfcNormalise(IfcCrossProduct(D1,D2))\IfcVector.Orientation, D1]);
END_FUNCTION;

FUNCTION IfcConstraintsParamBSpline
( Degree, UpKnots, UpCp : INTEGER;
  KnotMult : LIST OF INTEGER;
  Knots : LIST OF IfcParameterValue ) 
: BOOLEAN;


  LOCAL
    Result : BOOLEAN := TRUE;
    K, Sum : INTEGER;
  END_LOCAL;

  (* Find sum of knot multiplicities. *)
  Sum := KnotMult[1];
  REPEAT i := 2 TO UpKnots;
    Sum := Sum + KnotMult[i];
  END_REPEAT;

  (* Check limits holding for all B-spline parametrisations *)
  IF (Degree < 1) OR (UpKnots < 2) OR (UpCp < Degree) OR
    (Sum <> (Degree + UpCp + 2)) THEN
    Result := FALSE;
    RETURN(Result);
  END_IF;

  K := KnotMult[1];
  IF (K < 1) OR (K > Degree + 1) THEN
    Result := FALSE;
    RETURN(Result);
  END_IF;

  REPEAT i := 2 TO UpKnots;
    IF (KnotMult[i] < 1) OR (Knots[i] <= Knots[i-1]) THEN
      Result := FALSE;
      RETURN(Result);
    END_IF;
    K := KnotMult[i];
    IF (i < UpKnots) AND (K > Degree) THEN
      Result := FALSE;
      RETURN(Result);
    END_IF;
    IF (i = UpKnots) AND (K > Degree + 1) THEN
      Result := FALSE;
      RETURN(Result);
    END_IF;
  END_REPEAT;

  RETURN(result);
END_FUNCTION;

FUNCTION IfcConvertDirectionInto2D
(Direction : IfcDirection)
    : IfcDirection;
	
  LOCAL
    Direction2D : IfcDirection := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.,1.]);
  END_LOCAL;
  
  Direction2D.DirectionRatios[1] := Direction.DirectionRatios[1];
  Direction2D.DirectionRatios[2] := Direction.DirectionRatios[2];
  
  RETURN (Direction2D);
END_FUNCTION;

FUNCTION IfcCorrectDimensions
(m   : IfcUnitEnum; Dim : IfcDimensionalExponents) : LOGICAL;  
CASE m OF
  LENGTHUNIT : IF
    Dim = (IfcDimensionalExponents (1, 0, 0, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  MASSUNIT : IF
    Dim = (IfcDimensionalExponents (0, 1, 0, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  TIMEUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 1, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ELECTRICCURRENTUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 1, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  THERMODYNAMICTEMPERATUREUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 0, 1, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  AMOUNTOFSUBSTANCEUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 0, 0, 1, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  LUMINOUSINTENSITYUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 0, 0, 0, 1))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  PLANEANGLEUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  SOLIDANGLEUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  AREAUNIT : IF
    Dim = (IfcDimensionalExponents (2, 0, 0, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  VOLUMEUNIT : IF
    Dim = (IfcDimensionalExponents (3, 0, 0, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;

  ABSORBEDDOSEUNIT : IF
    Dim = (IfcDimensionalExponents (2, 0, -2, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  RADIOACTIVITYUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, -1, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ELECTRICCAPACITANCEUNIT : IF
    Dim = (IfcDimensionalExponents (-2, -1, 4, 2, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  DOSEEQUIVALENTUNIT : IF
    Dim = (IfcDimensionalExponents (2, 0, -2, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ELECTRICCHARGEUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 1, 1, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ELECTRICCONDUCTANCEUNIT : IF
    Dim = (IfcDimensionalExponents (-2, -1, 3, 2, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ELECTRICVOLTAGEUNIT : IF
    Dim = (IfcDimensionalExponents (2, 1, -3, -1, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ELECTRICRESISTANCEUNIT : IF
    Dim = (IfcDimensionalExponents (2, 1, -3, -2, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ENERGYUNIT : IF
    Dim = (IfcDimensionalExponents (2, 1, -2, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  FORCEUNIT : IF
    Dim = (IfcDimensionalExponents (1, 1, -2, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  FREQUENCYUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, -1, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  INDUCTANCEUNIT : IF
    Dim = (IfcDimensionalExponents (2, 1, -2, -2, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  ILLUMINANCEUNIT : IF
    Dim = (IfcDimensionalExponents (-2, 0, 0, 0, 0, 0, 1))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  LUMINOUSFLUXUNIT : IF
    Dim = (IfcDimensionalExponents (0, 0, 0, 0, 0, 0, 1))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  MAGNETICFLUXUNIT : IF
    Dim = (IfcDimensionalExponents (2, 1, -2, -1, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  MAGNETICFLUXDENSITYUNIT : IF
    Dim = (IfcDimensionalExponents (0, 1, -2, -1, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  POWERUNIT : IF
    Dim = (IfcDimensionalExponents (2, 1, -3, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;
  PRESSUREUNIT : IF
    Dim = (IfcDimensionalExponents (-1, 1, -2, 0, 0, 0, 0))
      THEN RETURN(TRUE);
      ELSE RETURN(FALSE);
    END_IF;

  OTHERWISE :
    RETURN (UNKNOWN);
END_CASE;
END_FUNCTION;

FUNCTION IfcCorrectLocalPlacement
(AxisPlacement:IfcAxis2Placement; 
   RelPlacement : IfcObjectPlacement):LOGICAL;

  IF (EXISTS(RelPlacement)) THEN
    IF ('IFC4.IFCGRIDPLACEMENT' IN TYPEOF(RelPlacement)) THEN
      RETURN(?);
    END_IF;
    IF ('IFC4.IFCLOCALPLACEMENT' IN TYPEOF(RelPlacement)) THEN
      IF ('IFC4.IFCAXIS2PLACEMENT2D' IN TYPEOF(AxisPlacement)) THEN
        RETURN(TRUE);
      END_IF;
      IF ('IFC4.IFCAXIS2PLACEMENT3D' IN TYPEOF(AxisPlacement)) THEN
        IF (RelPlacement\IfcLocalPlacement.RelativePlacement.Dim = 3) THEN
          RETURN(TRUE);
        ELSE
          RETURN(FALSE);
        END_IF;
      END_IF;
    END_IF;
  ELSE
    RETURN(TRUE);  
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION IfcCorrectObjectAssignment
(Constraint: IfcObjectTypeEnum; Objects : SET[1:?] OF IfcObjectDefinition)
  : LOGICAL ;
  
LOCAL
  Count : INTEGER := 0;
END_LOCAL;

    IF NOT(EXISTS(Constraint)) THEN 
      RETURN(TRUE);
    END_IF;
  
    CASE Constraint OF
      IfcObjectTypeEnum.NOTDEFINED : RETURN(TRUE);
      IfcObjectTypeEnum.PRODUCT :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCPRODUCT' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      IfcObjectTypeEnum.PROCESS :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCPROCESS' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      IfcObjectTypeEnum.CONTROL :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCCONTROL' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      IfcObjectTypeEnum.RESOURCE :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCRESOURCE' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      IfcObjectTypeEnum.ACTOR :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCACTOR' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      IfcObjectTypeEnum.GROUP :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCGROUP' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      IfcObjectTypeEnum.PROJECT :
        BEGIN
          Count := SIZEOF(QUERY(temp <* Objects | NOT('IFC4.IFCPROJECT' IN TYPEOF(temp))));
          RETURN(Count = 0);
        END;
      OTHERWISE : RETURN(?);
    END_CASE;
END_FUNCTION;

FUNCTION IfcCorrectUnitAssignment
(Units : SET [1:?] OF IfcUnit)
   : LOGICAL;

  LOCAL
    NamedUnitNumber    : INTEGER := 0;
    DerivedUnitNumber  : INTEGER := 0;
    MonetaryUnitNumber : INTEGER := 0;
    NamedUnitNames     : SET OF IfcUnitEnum := [];
    DerivedUnitNames   : SET OF IfcDerivedUnitEnum := [];
  END_LOCAL;

  NamedUnitNumber    := SIZEOF(QUERY(temp <* Units | ('IFC4.IFCNAMEDUNIT' IN TYPEOF(temp)) AND NOT(temp\IfcNamedUnit.UnitType = IfcUnitEnum.USERDEFINED)));
  DerivedUnitNumber  := SIZEOF(QUERY(temp <* Units | ('IFC4.IFCDERIVEDUNIT' IN TYPEOF(temp)) AND NOT(temp\IfcDerivedUnit.UnitType = IfcDerivedUnitEnum.USERDEFINED)));
  MonetaryUnitNumber := SIZEOF(QUERY(temp <* Units |  'IFC4.IFCMONETARYUNIT' IN TYPEOF(temp)));

  REPEAT i := 1 TO SIZEOF(Units);
    IF (('IFC4.IFCNAMEDUNIT' IN TYPEOF(Units[i])) AND NOT(Units[i]\IfcNamedUnit.UnitType = IfcUnitEnum.USERDEFINED)) THEN
        NamedUnitNames := NamedUnitNames + Units[i]\IfcNamedUnit.UnitType;
    END_IF;
    IF (('IFC4.IFCDERIVEDUNIT' IN TYPEOF(Units[i])) AND NOT(Units[i]\IfcDerivedUnit.UnitType = IfcDerivedUnitEnum.USERDEFINED)) THEN
        DerivedUnitNames := DerivedUnitNames + Units[i]\IfcDerivedUnit.UnitType;
    END_IF;
  END_REPEAT;

  RETURN((SIZEOF(NamedUnitNames) = NamedUnitNumber) AND (SIZEOF(DerivedUnitNames) = DerivedUnitNumber) AND (MonetaryUnitNumber <= 1));
END_FUNCTION;

FUNCTION IfcCrossProduct
(Arg1, Arg2 : IfcDirection) 
    : IfcVector;
LOCAL
  Mag : REAL;
  Res : IfcDirection;
  V1,V2  : LIST[3:3] OF REAL;
  Result : IfcVector;
END_LOCAL;

  IF (NOT EXISTS (Arg1) OR (Arg1.Dim = 2)) OR (NOT EXISTS (Arg2) OR (Arg2.Dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      V1  := IfcNormalise(Arg1)\IfcDirection.DirectionRatios;

      V2  := IfcNormalise(Arg2)\IfcDirection.DirectionRatios;
      Res := IfcRepresentationItem() || IfcGeometricRepresentationItem () 
             || IfcDirection([(V1[2]*V2[3] - V1[3]*V2[2]), (V1[3]*V2[1] - V1[1]*V2[3]), (V1[1]*V2[2] - V1[2]*V2[1])]);
      Mag := 0.0;
      REPEAT i := 1 TO 3;
        Mag := Mag + Res.DirectionRatios[i]*Res.DirectionRatios[i];
      END_REPEAT;
      IF (Mag > 0.0) THEN
        Result := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(Res, SQRT(Mag));
      ELSE
        Result := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(Arg1, 0.0);
      END_IF;
      RETURN(Result);
    END;
  END_IF;
END_FUNCTION;

FUNCTION IfcCurveDim
(Curve : IfcCurve)
       : IfcDimensionCount;

  IF ('IFC4.IFCLINE' IN TYPEOF(Curve))
    THEN RETURN(Curve\IfcLine.Pnt.Dim);
  END_IF;
  IF ('IFC4.IFCCONIC' IN TYPEOF(Curve))
    THEN RETURN(Curve\IfcConic.Position.Dim);
  END_IF;
  IF ('IFC4.IFCPOLYLINE' IN TYPEOF(Curve))
    THEN RETURN(Curve\IfcPolyline.Points[1].Dim);
  END_IF;
  IF ('IFC4.IFCTRIMMEDCURVE' IN TYPEOF(Curve))
    THEN RETURN(IfcCurveDim(Curve\IfcTrimmedCurve.BasisCurve));
  END_IF;
  IF ('IFC4.IFCCOMPOSITECURVE' IN TYPEOF(Curve))
    THEN RETURN(Curve\IfcCompositeCurve.Segments[1].Dim);
  END_IF;
  IF ('IFC4.IFCBSPLINECURVE' IN TYPEOF(Curve))
    THEN RETURN(Curve\IfcBSplineCurve.ControlPointsList[1].Dim);
  END_IF;
  IF ('IFC4.IFCOFFSETCURVE2D' IN TYPEOF(Curve))
    THEN RETURN(2); 
  END_IF;
  IF ('IFC4.IFCOFFSETCURVE3D' IN TYPEOF(Curve))
    THEN RETURN(3);
  END_IF;
  IF ('IFC4.IFCPCURVE' IN TYPEOF(Curve))
    THEN RETURN(3);
  END_IF;
RETURN (?);
END_FUNCTION;

FUNCTION IfcCurveWeightsPositive
( B: IfcRationalBSplineCurveWithKnots)
: BOOLEAN;

  LOCAL
    Result : BOOLEAN := TRUE;
  END_LOCAL;

  REPEAT i := 0 TO B.UpperIndexOnControlPoints;
    IF B.Weights[i] <= 0.0  THEN
      Result := FALSE;
      RETURN(Result);
    END_IF;
  END_REPEAT;
  RETURN(Result);
END_FUNCTION;

FUNCTION IfcDeriveDimensionalExponents
(UnitElements : SET [1:?] Of IfcDerivedUnitElement)
    : IfcDimensionalExponents;  
    LOCAL
    Result : IfcDimensionalExponents :=
            IfcDimensionalExponents(0, 0, 0, 0, 0, 0, 0);  
    END_LOCAL;
    REPEAT i := LOINDEX(UnitElements) TO HIINDEX(UnitElements);
        Result.LengthExponent := Result.LengthExponent +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.LengthExponent);
        Result.MassExponent := Result.MassExponent  +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.MassExponent);
        Result.TimeExponent := Result.TimeExponent +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.TimeExponent);
        Result.ElectricCurrentExponent := Result.ElectricCurrentExponent +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.ElectricCurrentExponent);
        Result.ThermodynamicTemperatureExponent := Result.ThermodynamicTemperatureExponent +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.ThermodynamicTemperatureExponent);
        Result.AmountOfSubstanceExponent := Result.AmountOfSubstanceExponent +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.AmountOfSubstanceExponent);
        Result.LuminousIntensityExponent := Result.LuminousIntensityExponent +
          (UnitElements[i].Exponent *
           UnitElements[i].Unit.Dimensions.LuminousIntensityExponent);
    END_REPEAT;  
    RETURN (Result);
END_FUNCTION;

FUNCTION IfcDimensionsForSiUnit
(n : IfcSiUnitName )     : IfcDimensionalExponents;
  CASE n OF
    METRE          : RETURN (IfcDimensionalExponents
                             (1, 0, 0, 0, 0, 0, 0));
    SQUARE_METRE   : RETURN (IfcDimensionalExponents
                             (2, 0, 0, 0, 0, 0, 0));
    CUBIC_METRE    : RETURN (IfcDimensionalExponents
                             (3, 0, 0, 0, 0, 0, 0));
    GRAM           : RETURN (IfcDimensionalExponents
                             (0, 1, 0, 0, 0, 0, 0));
    SECOND         : RETURN (IfcDimensionalExponents
                             (0, 0, 1, 0, 0, 0, 0));
    AMPERE         : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 1, 0, 0, 0));
    KELVIN         : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 1, 0, 0));
    MOLE           : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 0, 1, 0));
    CANDELA        : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 0, 0, 1));
    RADIAN         : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 0, 0, 0));
    STERADIAN      : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 0, 0, 0));
    HERTZ          : RETURN (IfcDimensionalExponents
                             (0, 0, -1, 0, 0, 0, 0));
    NEWTON         : RETURN (IfcDimensionalExponents
                             (1, 1, -2, 0, 0, 0, 0));
    PASCAL         : RETURN (IfcDimensionalExponents
                             (-1, 1, -2, 0, 0, 0, 0));
    JOULE          : RETURN (IfcDimensionalExponents
                             (2, 1, -2, 0, 0, 0, 0));
    WATT           : RETURN (IfcDimensionalExponents
                             (2, 1, -3, 0, 0, 0, 0));
    COULOMB        : RETURN (IfcDimensionalExponents
                             (0, 0, 1, 1, 0, 0, 0));
    VOLT           : RETURN (IfcDimensionalExponents
                             (2, 1, -3, -1, 0, 0, 0));
    FARAD          : RETURN (IfcDimensionalExponents
                             (-2, -1, 4, 2, 0, 0, 0));
    OHM            : RETURN (IfcDimensionalExponents
                             (2, 1, -3, -2, 0, 0, 0));
    SIEMENS        : RETURN (IfcDimensionalExponents
                             (-2, -1, 3, 2, 0, 0, 0));
    WEBER          : RETURN (IfcDimensionalExponents
                             (2, 1, -2, -1, 0, 0, 0));
    TESLA          : RETURN (IfcDimensionalExponents
                             (0, 1, -2, -1, 0, 0, 0));
    HENRY          : RETURN (IfcDimensionalExponents
                             (2, 1, -2, -2, 0, 0, 0));
    DEGREE_CELSIUS : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 1, 0, 0));
    LUMEN          : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 0, 0, 1));
    LUX            : RETURN (IfcDimensionalExponents
                             (-2, 0, 0, 0, 0, 0, 1));
    BECQUEREL      : RETURN (IfcDimensionalExponents
                             (0, 0, -1, 0, 0, 0, 0));
    GRAY           : RETURN (IfcDimensionalExponents
                             (2, 0, -2, 0, 0, 0, 0));
    SIEVERT        : RETURN (IfcDimensionalExponents
                             (2, 0, -2, 0, 0, 0, 0));
    OTHERWISE      : RETURN (IfcDimensionalExponents
                             (0, 0, 0, 0, 0, 0, 0));
  END_CASE;
END_FUNCTION;

FUNCTION IfcDotProduct
(Arg1, Arg2 : IfcDirection) 
    : REAL;
LOCAL
tmp : GENERIC;
END_LOCAL;
RETURN(tmp);
END_FUNCTION;

FUNCTION IfcFirstProjAxis
(ZAxis, Arg : IfcDirection) : IfcDirection;
LOCAL
  XAxis : IfcDirection;
  V     : IfcDirection;
  Z     : IfcDirection;
  XVec  : IfcVector;
END_LOCAL;

  IF (NOT EXISTS(ZAxis)) THEN
    RETURN (?) ;
  ELSE
    Z := IfcNormalise(ZAxis);
    IF NOT EXISTS(Arg) THEN
      IF (Z.DirectionRatios <> [1.0,0.0,0.0]) THEN
        V := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([1.0,0.0,0.0]);
      ELSE
        V := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF (Arg.Dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((IfcCrossProduct(Arg,Z).Magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        V := IfcNormalise(Arg);
      END_IF;
    END_IF;
    XVec  := IfcScalarTimesVector(IfcDotProduct(V, Z), Z);
    XAxis := IfcVectorDifference(V, XVec).Orientation;
    XAxis := IfcNormalise(XAxis);
  END_IF;
  RETURN(XAxis);
END_FUNCTION;

FUNCTION IfcGetBasisSurface
(C : IfcCurveOnSurface) : SET[0:2] OF IfcSurface;

  LOCAL
    Surfs : SET[0:2] OF IfcSurface;
    N : INTEGER;
  END_LOCAL;

  Surfs := [];
  IF 'IFC4.IFCPCURVE' IN TYPEOF (C) THEN
    Surfs := [C\IfcPCurve.BasisSurface];
  ELSE
    IF 'IFC4.IFCCOMPOSITECURVEONSURFACE' IN TYPEOF (C) THEN

    (* For an IfcCompositeCurveOnSurface the BasisSurface is the intersection
       of the BasisSurface of all the segments. *)

    N := SIZEOF(C\IfcCompositeCurve.Segments);
    Surfs := IfcGetBasisSurface(C\IfcCompositeCurve.Segments[1].ParentCurve);
    
      IF N > 1 THEN
        REPEAT i := 2 TO N;
          Surfs := Surfs * IfcGetBasisSurface(C\IfcCompositeCurve.Segments[1].ParentCurve);
        END_REPEAT;
      END_IF;
    END_IF;
  END_IF;
  RETURN(Surfs);
END_FUNCTION;

FUNCTION IfcListToArray
(Lis : LIST [0:?] OF GENERIC : T;
       Low,U : INTEGER) : ARRAY OF GENERIC : T;
   LOCAL
     N   : INTEGER;
     Res : ARRAY [Low:U] OF GENERIC : T;
   END_LOCAL;
      
   N := SIZEOF(Lis);
   IF (N <> (U-Low +1)) THEN
     RETURN(?);
   ELSE
     Res := [Lis[1] : N];
     REPEAT i := 2 TO N;
       Res[Low+i-1] := Lis[i];
     END_REPEAT;
     RETURN(Res);
   END_IF;
END_FUNCTION;

FUNCTION IfcLoopHeadToTail
(ALoop : IfcEdgeLoop) : LOGICAL;
   LOCAL
     N : INTEGER;
     P : LOGICAL := TRUE;
   END_LOCAL;
     
     N := SIZEOF (ALoop.EdgeList);
     REPEAT i := 2 TO N;
       P := P AND (ALoop.EdgeList[i-1].EdgeEnd :=:
                   ALoop.EdgeList[i].EdgeStart);
     END_REPEAT;     
     RETURN (P);
END_FUNCTION;

FUNCTION IfcMakeArrayOfArray
(Lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
 Low1, U1, Low2, U2 : INTEGER):
ARRAY [Low1:U1] OF ARRAY [Low2:U2] OF GENERIC : T;

  LOCAL
    Res : ARRAY[Low1:U1] OF ARRAY [Low2:U2] OF GENERIC : T;
  END_LOCAL;

  (* Check input dimensions for consistency *)
  IF (U1-Low1+1) <> SIZEOF(Lis) THEN
    RETURN (?);
  END_IF;
  IF (U2 - Low2 + 1 ) <> SIZEOF(Lis[1]) THEN
    RETURN (?) ;
  END_IF;

  (* Initialise Res with values from Lis[1] *)
  Res := [IfcListToArray(Lis[1], Low2, U2) : (U1-Low1 + 1)];
  REPEAT i := 2 TO HIINDEX(Lis);
    IF (U2-Low2+1) <> SIZEOF(Lis[i]) THEN
      RETURN (?);
    END_IF;
    Res[Low1+i-1] := IfcListToArray(Lis[i], Low2, U2);
  END_REPEAT;
  RETURN (Res);
END_FUNCTION;

FUNCTION IfcNormalise
(Arg : IfcVectorOrDirection) 
    : IfcVectorOrDirection;
LOCAL
  Ndim : INTEGER;
  V    : IfcDirection
         := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([1.,0.]); 
  Vec  : IfcVector 
         := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector (
            IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([1.,0.]), 1.);
  Mag  : REAL;
  Result : IfcVectorOrDirection
         := V;
END_LOCAL;

  IF NOT EXISTS (Arg) THEN
    RETURN (?);
  ELSE
    IF 'IFC4.IFCVECTOR' IN TYPEOF(Arg) THEN
      BEGIN
        Ndim := Arg\IfcVector.Dim;
	V.DirectionRatios := Arg\IfcVector.Orientation.DirectionRatios;
        Vec.Magnitude := Arg\IfcVector.Magnitude;
	Vec.Orientation := V;
        IF Arg\IfcVector.Magnitude = 0.0 THEN
          RETURN(?);
        ELSE
          Vec.Magnitude := 1.0;
        END_IF;
      END;
    ELSE
      BEGIN
        Ndim := Arg\IfcDirection.Dim;
        V.DirectionRatios := Arg\IfcDirection.DirectionRatios;
      END;
    END_IF;

    Mag := 0.0;
      REPEAT i := 1 TO Ndim;
        Mag := Mag + V.DirectionRatios[i]*V.DirectionRatios[i];
      END_REPEAT;
    IF Mag > 0.0 THEN
      Mag := SQRT(Mag);
      REPEAT i := 1 TO Ndim;
        V.DirectionRatios[i] := V.DirectionRatios[i]/Mag;
      END_REPEAT;
      IF 'IFC4.IFCVECTOR' IN TYPEOF(arg) THEN
        Vec.Orientation := V;
        Result := Vec;
      ELSE
        Result := V;
      END_IF;
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
  RETURN (Result);
END_FUNCTION;

FUNCTION IfcOrthogonalComplement
(Vec : IfcDirection) 
    : IfcDirection;
LOCAL
  Result : IfcDirection ;
END_LOCAL;
  IF NOT EXISTS (Vec) OR (Vec.Dim <> 2) THEN
    RETURN(?);
  ELSE
    Result := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([-Vec.DirectionRatios[2], Vec.DirectionRatios[1]]);
    RETURN(Result);
  END_IF;
END_FUNCTION;

FUNCTION IfcPathHeadToTail
(APath : IfcPath) : LOGICAL;
   LOCAL
     N : INTEGER := 0;
     P : LOGICAL := UNKNOWN;
   END_LOCAL;
     N := SIZEOF (APath.EdgeList);
   REPEAT i := 2 TO N;
      P := P AND (APath.EdgeList[i-1].EdgeEnd :=:
                  APath.EdgeList[i].EdgeStart);
   END_REPEAT;
   RETURN (P);
END_FUNCTION;

FUNCTION IfcSameAxis2Placement
(ap1, ap2 : IfcAxis2Placement; Epsilon : REAL)
  : LOGICAL ;

  RETURN (IfcSameDirection(ap1.P[1],ap2.P[1],Epsilon) AND
          IfcSameDirection(ap1.P[2],ap2.P[2],Epsilon) AND
          IfcSameCartesianPoint(ap1.Location,ap1.Location,Epsilon));
END_FUNCTION;

FUNCTION IfcSameCartesianPoint
(cp1, cp2 : IfcCartesianPoint; Epsilon : REAL)
	: LOGICAL;
  
  LOCAL
    cp1x : REAL := cp1.Coordinates[1];
    cp1y : REAL := cp1.Coordinates[2];
    cp1z : REAL := 0;
    cp2x : REAL := cp2.Coordinates[1];
    cp2y : REAL := cp2.Coordinates[2];
    cp2z : REAL := 0;
  END_LOCAL;

  IF (SIZEOF(cp1.Coordinates) > 2) THEN
    cp1z := cp1.Coordinates[3];
  END_IF;

  IF (SIZEOF(cp2.Coordinates) > 2) THEN
    cp2z := cp2.Coordinates[3];
  END_IF;

  RETURN (IfcSameValue(cp1x,cp2x,Epsilon) AND
          IfcSameValue(cp1y,cp2y,Epsilon) AND
          IfcSameValue(cp1z,cp2z,Epsilon));
END_FUNCTION;

FUNCTION IfcSameDirection
(dir1, dir2 : IfcDirection; Epsilon : REAL)
	: LOGICAL;
  LOCAL
    dir1x : REAL := dir1.DirectionRatios[1];
    dir1y : REAL := dir1.DirectionRatios[2];
    dir1z : REAL := 0;
    dir2x : REAL := dir2.DirectionRatios[1];
    dir2y : REAL := dir2.DirectionRatios[2];
    dir2z : REAL := 0;
  END_LOCAL;

  IF (SIZEOF(dir1.DirectionRatios) > 2) THEN
    dir1z := dir1.DirectionRatios[3];
  END_IF;

  IF (SIZEOF(dir2.DirectionRatios) > 2) THEN
    dir2z := dir2.DirectionRatios[3];
  END_IF;
  
  RETURN (IfcSameValue(dir1x,dir2x,Epsilon) AND
          IfcSameValue(dir1y,dir2y,Epsilon) AND
          IfcSameValue(dir1z,dir2z,Epsilon));
END_FUNCTION;

FUNCTION IfcSameValidPrecision
(Epsilon1, Epsilon2 : REAL) : LOGICAL ;
  LOCAL
    ValidEps1, ValidEps2 : REAL;
    DefaultEps           : REAL := 0.000001;
    DerivationOfEps      : REAL := 1.001;
    UpperEps             : REAL := 1.0;
  END_LOCAL;
  
    ValidEps1 := NVL(Epsilon1, DefaultEps);
    ValidEps2 := NVL(Epsilon2, DefaultEps);
    RETURN ((0.0 < ValidEps1) AND (ValidEps1 <= (DerivationOfEps * ValidEps2)) AND 
            (ValidEps2 <= (DerivationOfEps * ValidEps1)) AND (ValidEps2 < UpperEps));
END_FUNCTION;

FUNCTION IfcSameValue
(Value1, Value2 : REAL; Epsilon : REAL)
	: LOGICAL;
  LOCAL
    ValidEps    : REAL;
    DefaultEps  : REAL := 0.000001;
  END_LOCAL;
  
  ValidEps := NVL(Epsilon, DefaultEps);
  RETURN ((Value1 + ValidEps > Value2) AND (Value1 < Value2 + ValidEps));
END_FUNCTION;

FUNCTION IfcScalarTimesVector
(Scalar : REAL; Vec : IfcVectorOrDirection)
    : IfcVector;
LOCAL
  V : IfcDirection;
  Mag : REAL;
  Result : IfcVector;
END_LOCAL;

  IF NOT EXISTS (Scalar) OR NOT EXISTS (Vec) THEN
    RETURN (?) ;
  ELSE
    IF 'IFC4.IFCVECTOR' IN TYPEOF (Vec) THEN
      V := Vec\IfcVector.Orientation;
      Mag := Scalar * Vec\IfcVector.Magnitude;
    ELSE
      V := Vec;
      Mag := Scalar;
    END_IF;
    IF (Mag < 0.0 ) THEN
      REPEAT i := 1 TO SIZEOF(V.DirectionRatios);
        V.DirectionRatios[i] := -V.DirectionRatios[i];
      END_REPEAT;
      Mag := -Mag;
    END_IF;
    Result := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(IfcNormalise(V), Mag);
  END_IF;
  RETURN (Result);
END_FUNCTION;

FUNCTION IfcSecondProjAxis
(ZAxis, XAxis, Arg: IfcDirection) 
    : IfcDirection;
LOCAL
  YAxis : IfcVector;
  V     : IfcDirection;
  Temp  : IfcVector;
END_LOCAL;

  IF NOT EXISTS(Arg) THEN
    V := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,1.0,0.0]);
  ELSE
    V := Arg;
  END_IF;
  Temp  := IfcScalarTimesVector(IfcDotProduct(V, ZAxis), ZAxis);
  YAxis := IfcVectorDifference(V, Temp);
  Temp  := IfcScalarTimesVector(IfcDotProduct(V, XAxis), XAxis);
  YAxis := IfcVectorDifference(YAxis, Temp);
  YAxis := IfcNormalise(YAxis);
  RETURN(YAxis.Orientation);
END_FUNCTION;

FUNCTION IfcShapeRepresentationTypes
(RepType : IfcLabel; Items : SET OF IfcRepresentationItem) : LOGICAL;
    
    LOCAL
      Count : INTEGER := 0;
    END_LOCAL;

    CASE RepType OF 
    'Point' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCPOINT' IN TYPEOF(temp))));
      END;

    'PointCloud' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCCARTESIANPOINTLIST3D' IN TYPEOF(temp))));
      END;

    'Curve' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCCURVE' IN TYPEOF(temp))));
      END;

    'Curve2D' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCCURVE' IN TYPEOF(temp)) 
                 AND (temp\IfcCurve.Dim = 2)));
      END;

    'Curve3D' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCCURVE' IN TYPEOF(temp)) 
                 AND (temp\IfcCurve.Dim = 3)));
      END;

    'Surface' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCSURFACE' IN TYPEOF(temp))));
      END;

    'Surface2D' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCSURFACE' IN TYPEOF(temp)) 
                 AND (temp\IfcSurface.Dim = 2)));
      END;

    'Surface3D' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCSURFACE' IN TYPEOF(temp)) 
                 AND (temp\IfcSurface.Dim = 3)));
      END;

    'FillArea' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCANNOTATIONFILLAREA' IN TYPEOF(temp))));
      END;

    'Text' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCTEXTLITERAL' IN TYPEOF(temp))));
      END;

    'AdvancedSurface' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | 'IFC4.IFCBSPLINESURFACE' IN TYPEOF(temp)));
      END;

    'Annotation2D' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | (
                  SIZEOF(TYPEOF(temp) * [
                   'IFC4.IFCPOINT',
                   'IFC4.IFCCURVE',
                   'IFC4.IFCGEOMETRICCURVESET',
                   'IFC4.IFCANNOTATIONFILLAREA',
                   'IFC4.IFCDEFINEDSYMBOL',
                   'IFC4.IFCTEXTLITERAL']) = 1)
                 ));
      END;

    'GeometricSet' : 
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCGEOMETRICSET' IN TYPEOF(temp))
                 OR ('IFC4.IFCPOINT' IN TYPEOF(temp))
                 OR ('IFC4.IFCCURVE' IN TYPEOF(temp))
                 OR ('IFC4.IFCSURFACE' IN TYPEOF(temp))));
      END;

    'GeometricCurveSet' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCGEOMETRICCURVESET' IN TYPEOF(temp))
                 OR ('IFC4.IFCGEOMETRICSET' IN TYPEOF(temp))
                 OR ('IFC4.IFCPOINT' IN TYPEOF(temp))
                 OR ('IFC4.IFCCURVE' IN TYPEOF(temp))));
         REPEAT i:=1 TO HIINDEX(Items);  
           IF ('IFC4.IFCGEOMETRICSET' IN TYPEOF(Items[i]))
           THEN
             IF (SIZEOF(QUERY(temp <* Items[i]\IfcGeometricSet.Elements | 'IFC4.IFCSURFACE' IN TYPEOF(temp))) > 0)
             THEN
               Count := Count - 1;
             END_IF;
           END_IF;
         END_REPEAT;
      END;

    'Tesselation' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | 'IFC4.IFCTESSELATEDITEM' IN TYPEOF(temp)));
      END;

    'SurfaceModel' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | SIZEOF([
                   'IFC4.IFCSHELLBASEDSURFACEMODEL',
                   'IFC4.IFCFACEBASEDSURFACEMODEL',
                   'IFC4.IFCFACETEDBREP',
                   'IFC4.IFCFACETEDBREPWITHVOIDS'] * TYPEOF(temp)) >= 1
                 ));      
      END;

    'SolidModel' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCSOLIDMODEL' IN TYPEOF(temp))));            
      END;

    'SweptSolid' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | (SIZEOF([
                   'IFC4.IFCEXTRUDEDAREASOLID',
                   'IFC4.IFCREVOLVEDAREASOLID'] * TYPEOF(temp)) >= 1
                   ) AND (SIZEOF([
                   'IFC4.IFCEXTRUDEDAREASOLIDTAPERED',
                   'IFC4.IFCREVOLVEDAREASOLIDTAPERED'] * TYPEOF(temp)) = 0
                   )
                 ));                             
      END;

    'AdvancedSweptSolid' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | SIZEOF([
                   'IFC4.IFCSURFACECURVESWEPTAREASOLID',
                   'IFC4.IFCFIXEDREFERENCESWEPTAREASOLID',
                   'IFC4.IFCEXTRUDEDAREASOLIDTAPERED',
                   'IFC4.IFCREVOLVEDAREASOLIDTAPERED',
                   'IFC4.IFCSWEPTDISKSOLID'] *  TYPEOF(temp)) >= 1
                 ));      
      END;

    'CSG' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | SIZEOF([
                   'IFC4.IFCBOOLEANRESULT',
                   'IFC4.IFCCSGPRIMITIVE3D',
                   'IFC4.IFCCSGSOLID'] *  TYPEOF(temp)) >= 1
                 ));            
      END;

    'Clipping' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCBOOLEANCLIPPINGRESULT' IN TYPEOF(temp))));            
      END;

    'Brep' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCFACETEDBREP' IN TYPEOF(temp))));      
      END;

    'AdvancedBrep' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCADVANCEDBREP' IN TYPEOF(temp))));      
      END;

    'BoundingBox' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCBOUNDINGBOX' IN TYPEOF(temp))));
        IF (SIZEOF(Items) > 1)
        THEN
          Count := 0;
        END_IF;   
      END;

    'SectionedSpine' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCSECTIONEDSPINE' IN TYPEOF(temp))));      
      END;

    'LightSource' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCLIGHTSOURCE' IN TYPEOF(temp))));      
      END;

    'MappedRepresentation' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | ('IFC4.IFCMAPPEDITEM' IN TYPEOF(temp))));  
      END;

     OTHERWISE : RETURN(?);
    END_CASE;
    RETURN (Count = SIZEOF(Items));
END_FUNCTION;

FUNCTION IfcSurfaceWeightsPositive
( B: IfcRationalBSplineSurfaceWithKnots) 
: BOOLEAN;

  LOCAL
    Result : BOOLEAN := TRUE;
  END_LOCAL;

  REPEAT i := 0 TO B\IfcBSplineSurface.UUpper;
    REPEAT j := 0 TO B\IfcBSplineSurface.VUpper;
      IF (B.Weights[i][j] <= 0.0) THEN
        Result := FALSE;
        RETURN(Result);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(Result);
END_FUNCTION;

FUNCTION IfcTaperedSweptAreaProfiles
(StartArea, EndArea : IfcProfileDef)
 : LOGICAL;

LOCAL
   Result : LOGICAL := FALSE;
END_LOCAL;
   
IF ('IFC4.IFCPARAMETERIZEDPROFILEDEF' IN TYPEOF(StartArea)) THEN
   IF ('IFC4.IFCDERIVEDPROFILEDEF' IN TYPEOF(EndArea)) THEN
      Result := (StartArea :=: EndArea\IfcDerivedProfileDef.ParentProfile);
   ELSE
      Result := (TYPEOF(StartArea) = TYPEOF(EndArea));
   END_IF;
ELSE
   IF ('IFC4.IFCDERIVEDPROFILEDEF' IN TYPEOF(EndArea)) THEN
      Result := (StartArea :=: EndArea\IfcDerivedProfileDef.ParentProfile);
   ELSE
      Result := FALSE;
   END_IF;
END_IF;

RETURN(Result);
END_FUNCTION;

FUNCTION IfcTopologyRepresentationTypes
(RepType : IfcLabel; Items : SET OF IfcRepresentationItem) : LOGICAL;
    
    LOCAL
      Count : INTEGER := 0;
    END_LOCAL;

    CASE RepType OF 
    'Vertex' :
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | 
                  ('IFC4.IFCVERTEX' IN TYPEOF(temp))));
      END;
    'Edge' : 
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | 
                  ('IFC4.IFCEDGE' IN TYPEOF(temp))));
      END;
    'Path' : 
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | 
                  ('IFC4.IFCPATH' IN TYPEOF(temp))));
      END;
    'Face' : 
      BEGIN 
        Count := SIZEOF(QUERY(temp <* Items | 
                  ('IFC4.IFCFACE' IN TYPEOF(temp))));
      END;
    'Shell' :
      BEGIN
        Count := SIZEOF(QUERY(temp <* Items | 
                  ('IFC4.IFCOPENSHELL' IN TYPEOF(temp))
                    OR ('IFC4.IFCCLOSEDSHELL' IN TYPEOF(temp))));
      END;
    'Undefined': RETURN(TRUE);
     OTHERWISE : RETURN(?);
    END_CASE;
    RETURN (Count = SIZEOF(Items));
END_FUNCTION;

FUNCTION IfcUniquePropertyName
(Properties : SET [1:?] OF IfcProperty)
:BOOLEAN;
LOCAL
tmp : GENERIC;
END_LOCAL;
RETURN(tmp);
END_FUNCTION;

FUNCTION IfcUniquePropertyTemplateNames
(Properties : SET [1:?] OF IfcPropertyTemplate)
:LOGICAL;

LOCAL
  Names : SET OF IfcIdentifier := [];
END_LOCAL;

REPEAT i:=1 TO HIINDEX(Properties);
  Names := Names + Properties[i].Name;
END_REPEAT;
RETURN (SIZEOF(Names) = SIZEOF(Properties));
END_FUNCTION;

FUNCTION IfcUniqueQuantityNames
(Properties : SET [1:?] OF IfcPhysicalQuantity)
:LOGICAL;
LOCAL
tmp : GENERIC;
END_LOCAL;
RETURN(tmp);
END_FUNCTION;

FUNCTION IfcVectorDifference
(Arg1, Arg2 : IfcVectorOrDirection)
    : IfcVector;
LOCAL
  Result : IfcVector;
  Res, Vec1, Vec2 : IfcDirection;
  Mag, Mag1, Mag2 : REAL;
  Ndim : INTEGER;
END_LOCAL;

  IF ((NOT EXISTS (Arg1)) OR (NOT EXISTS (Arg2))) OR (Arg1.Dim <> Arg2.Dim) THEN
    RETURN (?) ;
  ELSE
    BEGIN
      IF 'IFC4.IFCVECTOR' IN TYPEOF(Arg1) THEN
        Mag1 := Arg1\IfcVector.Magnitude;
        Vec1 := Arg1\IfcVector.Orientation;
      ELSE
        Mag1 := 1.0;
        Vec1 := Arg1;
      END_IF;
      IF 'IFC4.IFCVECTOR' IN TYPEOF(Arg2) THEN
        Mag2 := Arg2\IfcVector.Magnitude;
        Vec2 := Arg2\IfcVector.Orientation;
      ELSE
        Mag2 := 1.0;
        Vec2 := Arg2;
      END_IF;
      Vec1 := IfcNormalise (Vec1);
      Vec2 := IfcNormalise (Vec2);
      Ndim := SIZEOF(Vec1.DirectionRatios);
      Mag  := 0.0;
      Res  := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0:Ndim]);

      REPEAT i := 1 TO Ndim;
        Res.DirectionRatios[i] := Mag1*Vec1.DirectionRatios[i] - Mag2*Vec2.DirectionRatios[i];
        Mag := Mag + (Res.DirectionRatios[i]*Res.DirectionRatios[i]);
      END_REPEAT;

      IF (Mag > 0.0 ) THEN
        Result := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector( Res, SQRT(Mag));
      ELSE
        Result := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector( Vec1, 0.0);
      END_IF;
    END;
  END_IF;
  RETURN (Result);
END_FUNCTION;

FUNCTION IfcVectorSum
(Arg1, Arg2 : IfcVectorOrDirection)
    : IfcVector;
LOCAL
tmp : GENERIC;
END_LOCAL;
RETURN(tmp);
END_FUNCTION;

RULE IfcRepresentationContextSameWCS FOR
	(IfcGeometricRepresentationContext);
LOCAL
  IsDifferent  : LOGICAL := FALSE;
END_LOCAL;
  IF (SIZEOF(IfcGeometricRepresentationContext) > 1)
  THEN
    REPEAT i := 2 TO HIINDEX(IfcGeometricRepresentationContext);
      IF (IfcGeometricRepresentationContext[1].WorldCoordinateSystem :<>: IfcGeometricRepresentationContext[i].WorldCoordinateSystem)
      THEN
        IsDifferent := (NOT(IfcSameValidPrecision(IfcGeometricRepresentationContext[1].Precision,
                                                  IfcGeometricRepresentationContext[i].Precision)))
                    OR (NOT(IfcSameAxis2Placement(IfcGeometricRepresentationContext[1].WorldCoordinateSystem,
                                                  IfcGeometricRepresentationContext[i].WorldCoordinateSystem,
                                                  IfcGeometricRepresentationContext[1].Precision)));
        IF (IsDifferent = TRUE) THEN
          ESCAPE;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
    WHERE
      WR1 : IsDifferent = FALSE;
END_RULE;

RULE IfcSingleProjectInstance FOR
	(IfcProject);

    WHERE
      WR1 : SIZEOF(IfcProject) <= 1;
END_RULE;

END_SCHEMA;
